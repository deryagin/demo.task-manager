# Микросервис планирования заданий

Тестовое задание на вакансию BackEnd Node.JS Developer (Middle/Senior) одной известной компании.

## Общие сведения

- В ядре системы есть множество методов, которые вызываются по крону (разные методы имеют
разное расписание запусков).
- Проблема заключается в том, что ядро может быть запущено одновременно в нескольких
контейнерах и каждый из этих контейнеров не знает запустил ли другой контейнер нужный процесс
по расписанию.
- В целевой модели ядро вообще не должно управлять запуском задач по расписанию. Крон не должен
использоваться. Ядро должно предоставлять веб-методы для запуска заданий извне.
- В рамках текущей задачи должен быть разработан сервис, который будет вызывать нужные методы
API по расписанию независимо от того, в скольких контейнерах запущено ядро системы. Сам
разрабатываемый микросервис будет работать только в одном экземпляре (запуск только в одном
контейнере без масштабирования обеспечит Kubernetes).
- Фактически запуск методов по расписанию - это своевременный вызов веб-методов существующего
API ядра системы.
- Все запуски веб-методов по расписанию должны логироваться. Для логирования запусков
используется вызов специального метода в API ядра системы.

## Технические особенности

- Системное имя микросервиса: TaskManager
- Запускаемые по расписанию процессы должны вызываться с помощью HTTP-метода PUT.
- Конфигурация сервиса (какие url-ы по какому расписанию дергать) определяется в файле
«config.json», см. ниже.
- Адрес точки подключения к API ядра определен в переменных окружения: APIURI
- Вызов методов API ядра требует авторизации. Для этого при вызове любого метода указывается токен
авторизации (в заголовке запроса): x-auth-token.
- Токен авторизации в API определен в переменных окружения: APITOKEN
- Пример вызова веб-метода ядра:

```
PUT <APIURI>/<methodName>
x-auth-token: <APITOKEN>
```

## Файл конфигурации config.json
- Пример файла конфигурации с пояснениями. Структура файла может быть расширена по усмотрению
разработчика:
```
{
    "rules": [
        {
            "methodName": "firstmethod", // Имя метода, который должен быть вызван
            "frequency": "day", // Возможные варианты: minute, hour, day, week, month
            "startDate": "01.01.2020 10:00:00" // Начиная с этой даты/времени, раз в frequ
ency должен вызываться methodName
        },
        {
            // Следующее правило
        }
    ]
}
```

## Управление историей запусков

После вызова какого-либо веб-метода по расписанию результат вызова должен быть залогирован.
Логирование результатов производится в БД системы. Разрабатываемому сервису доступно API ядра для
логирования (сам он напрямую в БД ничего писать не должен):

- Метод, который позволяет получить для определенного метода дату последнего успешного запуска:
```
### Запрос
GET <APIURI>/taskManagerLogs/last/<methodName>
x-auth-token: <APITOKEN>

### Ответ
200 OK
{
    "_id": "c1737d27-742d-45ad-ad6c-97982bc42f5e",
    "methodName": "firstmethod", // Имя вызванного метода
    "dateStart": "2020-01-20 10:00:05", // Дата/время вызова
    "dateEnd": "2020-01-20 10:02:33", // Дата/время получения ответа
    "result": "OK", // Варианты: OK, Error
    "errorDescription": "" // Подробности об ошибке, которые вернул вызванный веб-метод
}
```

- Метод, который позволяет записать результат запуска:
```
### Запрос
PUT &lt;APIURI&gt;/taskManagerLogs/create
x-auth-token: &lt;APITOKEN&gt;
{
    "methodName": "firstmethod", // Имя вызванного метода
    "dateStart": "2020-01-20 10:00:05", // Дата/время вызова
    "dateEnd": "2020-01-20 10:02:33", // Дата/время получения ответа
    "result": "OK", // Варианты: OK, Error
    "errorDescription": "" // Подробности об ошибке, которые вернул вызванный веб-метод
}

### Ответ
200 OK
```

## Алгоритм работы

### Запуск сервиса

1. Прочитать параметры подключения к API из переменных окружения.
2. Прочитать правила конфигурации из файла конфигурации.
3. Запросить у API даты последних запусков методов (taskManagerLogs/last/<methodName>) для
определения расписания дальнейших запусков в соответствии с правилами конфигурации. Запрашивать
только для методов, определенных в правилах конфигурации.
4. Сформировать расписание запусков на основе правил конфигурации:
    4.1. Для каждого правила должна быть рассчитана дата следующего запуска.
    4.2. Если метод еще не запускался, то дата старта должна быть определена в соответствии с расписанием.
    4.3. Если метод запускался, но последний запуск был не успешен, то дата старта должна быть текущая.
    4.4. Если метод запускался и последний запуск был успешен, то дата старта должна быть рассчитана по
правилам конфигурации относительно последнего успешного запуска.
5. Перейти в режим ожидания наступления дат из сформированного расписания.

### Работа сервиса
1. Ожидать наступления даты из расписания, сформированного при запуске.
2. Когда дата наступила, то вызвать соответствующий веб-метод.
3. Дождаться ответа от API (синхронный запрос).
4. Передать в API результат запуска.
5. Если запуск был успешен, то запланировать следующий запуск относительно даты старта последнего
запуска в соответствии с правилом конфигурации (через час, через день и т.п.).
6. Если запуск был неуспешен, то запланировать следующий запуск относительно даты старта последнего
запуска + 1 час.
7. Перейти к обработке следующего правила.
8. Не вызывать параллельно правила. Если сейчас должны быть обработаны несколько правил, то
обрабатывать и последовательно по одному.
